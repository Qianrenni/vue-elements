<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
    <title>Q Loading Animation - Fullscreen</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            width: 100%;
            height: 100%;
            background-color: #000;
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
<canvas id="qCanvas"></canvas>

<script>
    const canvas = document.getElementById('qCanvas');
    const ctx = canvas.getContext('2d');

    // 设置 canvas 全屏
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // 中心点
    let centerX, centerY;

    // 动画参数
    const duration = 2000; // 每个阶段持续时间（毫秒）
    let startTime = null;
    let currentStage = 0; // 0: 四角汇聚, 1: 画椭圆, 2: 画一撇

    // 椭圆参数
    const rx = 20;
    const ry = 25;

    // 偏移量
    const curveEndOffset = 20; // 曲线终点向角方向偏移 20px
    const tailOffset1 = 15;    // 一撇起点偏移
    const tailLength = 15;     // 一撇长度

    // 缓动函数
    function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
    }

    function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    }

    // 三次贝塞尔插值
    function cubicBezier(p0, p1, p2, p3, t) {
        const mt = 1 - t;
        return mt ** 3 * p0 +
            3 * mt ** 2 * t * p1 +
            3 * mt * t ** 2 * p2 +
            t ** 3 * p3;
    }

    // 获取中心点
    function updateCenter() {
        centerX = canvas.width / 2;
        centerY = canvas.height / 2;
    }

    // 四个角
    const corners = [
        {x: 0, y: 0},                    // 左上
        {x: canvas.width, y: 0},         // 右上
        {x: canvas.width, y: canvas.height}, // 右下
        {x: 0, y: canvas.height}         // 左下
    ];

    // 计算每个角方向的偏移终点（从中心向角方向推 20px）
    function getEndPoints() {
        return corners.map(corner => {
            const dx = corner.x - centerX;
            const dy = corner.y - centerY;
            const len = Math.hypot(dx, dy);
            const unitX = dx / len;
            const unitY = dy / len;
            return {
                x: centerX + unitX * curveEndOffset,
                y: centerY + unitY * curveEndOffset
            };
        });
    }

    // 控制点配置（可调整曲线弧度）
    function getControlPoints() {
        return [
            {c1: {x: 100, y: 0}, c2: {x: centerX - 40, y: centerY - 60}}, // 左上
            {c1: {x: canvas.width - 100, y: 0}, c2: {x: centerX + 40, y: centerY - 60}}, // 右上
            {c1: {x: canvas.width - 100, y: canvas.height}, c2: {x: centerX + 40, y: centerY + 60}}, // 右下
            {c1: {x: 100, y: canvas.height}, c2: {x: centerX - 40, y: centerY + 60}} // 左下
        ];
    }

    // 绘制部分贝塞尔曲线（按进度）
    function drawPartialBezier(start, cp1, cp2, end, progress) {
        const numSegments = 50;
        const drawTo = Math.floor(numSegments * progress);
        if (drawTo <= 0) return;

        ctx.beginPath();
        ctx.moveTo(start.x, start.y);

        for (let i = 1; i <= drawTo; i++) {
            const t = i / numSegments;
            const x = cubicBezier(start.x, cp1.x, cp2.x, end.x, t);
            const y = cubicBezier(start.y, cp1.y, cp2.y, end.y, t);
            ctx.lineTo(x, y);
        }
        ctx.stroke();
    }

    // 画椭圆（从 0 到 2π 逐步绘制）
    function drawPartialEllipse(progress) {
        ctx.beginPath();
        const startAngle = 0;
        const endAngle = Math.PI * 2 * progress;

        // 使用椭圆路径（分段近似）
        const numSegments = 60;
        const endSegment = Math.floor(numSegments * progress);

        for (let i = 0; i <= endSegment; i++) {
            const angle = startAngle + (endAngle - startAngle) * (i / numSegments);
            const x = centerX + rx * Math.cos(angle);
            const y = centerY + ry * Math.sin(angle);
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    }

    // 画一撇（从中心右下偏移点出发画直线）
    function drawTail(progress) {
        const startX = centerX + tailOffset1;
        const startY = centerY + tailOffset1;
        const endX = startX + tailLength;
        const endY = startY + tailLength;

        const x = startX + (endX - startX) * progress;
        const y = startY + (endY - startY) * progress;

        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(x, y);
        ctx.stroke();
    }

    // 主动画函数
    function animate(currentTime) {
        updateCenter();
        if (!startTime) startTime = currentTime;

        const elapsed = currentTime - startTime;
        const stageTime = elapsed % (duration * 3);

        // 更新阶段
        if (stageTime < duration) {
            currentStage = 0; // 四角汇聚
        } else if (stageTime < duration * 2) {
            currentStage = 1; // 画椭圆
        } else {
            currentStage = 2; // 画一撇
        }

        const stageProgress = easeInOutCubic((stageTime % duration) / duration);

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 样式
        ctx.strokeStyle = '#00ffcc';
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';

        // 阶段 0：四角曲线汇聚
        if (currentStage === 0) {
            const endPoints = getEndPoints();
            const controlPoints = getControlPoints();

            for (let i = 0; i < 4; i++) {
                const t = Math.max(0, Math.min(1, stageProgress * (1 + i * 0.3))); // 错开出现
                drawPartialBezier(
                    corners[i],
                    controlPoints[i].c1,
                    controlPoints[i].c2,
                    endPoints[i],
                    t
                );
            }
        }

        // 阶段 1：画椭圆（只有当前阶段才继续画）
        if (currentStage >= 1) {
            const ellipseProgress = currentStage === 1 ? stageProgress : 1;
            drawPartialEllipse(ellipseProgress);
        }

        // 阶段 2：画一撇
        if (currentStage >= 2) {
            const tailProgress = currentStage === 2 ? stageProgress : 1;
            drawTail(tailProgress);
        }

        requestAnimationFrame(animate);
    }

    // 初始化并开始动画
    resizeCanvas();
    requestAnimationFrame(animate);
</script>
</body>
</html>
